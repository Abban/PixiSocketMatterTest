<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collider</title>
</head>
<body>
<canvas id="game"></canvas>

<script src="/resources/matter/matter-dev.js"></script>
<script src="/resources/pixijs/pixi.js"></script>

<script>
    const canvas = document.getElementById('game');

    let Engine = Matter.Engine,
        World = Matter.World,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Common = Matter.Common,
        Bodies = Matter.Bodies,
        Events = Matter.Events,
        Mouse = Matter.Mouse,
        MouseConstraint = Matter.MouseConstraint,
        Constraint = Matter.Constraint,
        Vector = Matter.Vector,
        Body = Matter.Body;

    // create engine
    let engine = Engine.create(),
        world = engine.world;

    engine.world.gravity.y = 0;

    let ball = Bodies.circle(400, 300, 32, {restitution: 0.6, friction: 0.1, label: 'ball'});
    Body.setVelocity(ball, {x: Common.random(-70, 70), y: Common.random(-70, 70)});

    let collider = Bodies.circle(400, 300, 16, {mass: 200, label: 'kicker'});

    World.add(world, [
        // walls
        Bodies.rectangle(400, 0, 800, 50, {isStatic: true}),
        Bodies.rectangle(400, 600, 800, 50, {isStatic: true}),
        Bodies.rectangle(800, 300, 50, 600, {isStatic: true}),
        Bodies.rectangle(0, 300, 50, 600, {isStatic: true}),

        ball,
        collider
    ]);

    // create runner
    let runner = Runner.create();
    Runner.run(runner, engine);

    // SWAP WITH PIXI?
    let render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: 800,
            height: 600,
            showAngleIndicator: true,
            wireframes: false
        }
    });

    Render.run(render);

    // add mouse control
    // let mouse = Mouse.create(render.canvas),
    //     mouseConstraint = MouseConstraint.create(engine, {
    //         mouse: mouse,
    //         constraint: {
    //             stiffness: 0.2,
    //             render: {
    //                 visible: false
    //             }
    //         }
    //     });
    //
    // World.add(world, mouseConstraint);
    //
    // // keep the mouse in sync with rendering
    // render.mouse = mouse;

    let app = new PIXI.Application({
        backgroundColor: 0x6AAF1F,
        view: canvas,
        width: 800,
        height: 600,
        antialias: true,
        transparent: false,
        resolution: 1
    });

    const texture = PIXI.Texture.from('resources/sprites/Ball.png');
    const ballSprite = new PIXI.Sprite.from(texture);
    ballSprite.anchor.set(0.5);
    ballSprite.x = app.screen.width / 2;
    ballSprite.y = app.screen.height / 2;

    app.stage.addChild(ballSprite);

    const handle = new PIXI.Sprite.from(
        PIXI.Texture.from('resources/sprites/Blue-Man.png')
    );
    handle.anchor.set(0.5);
    handle.x = app.screen.width / 2;
    handle.y = app.screen.height / 2;

    app.stage.addChild(handle);

    // make the sprite interactive
    handle.interactive = true;
    handle.buttonMode = true;

    handle.on('pointerdown', onDragStart)
        .on('pointerup', onDragEnd)
        .on('pointerupoutside', onDragEnd)
        .on('pointermove', onDragMove);


    function onDragStart(event) {
        console.log(event);
        this.data = event.data;
        this.startPositionY = this.y;
        this.clickStartPosition = this.data.getLocalPosition(this.parent);
        this.alpha = 0.5;
        this.dragging = true;
    }

    function onDragEnd() {
        this.alpha = 1;
        this.dragging = false;
        this.data = null;
        this.startPositionY = null;
    }

    function onDragMove() {
        if (!this.dragging) {
            return;
        }

        const newPosition = this.data.getLocalPosition(this.parent);
        const newPositionY = this.startPositionY - (this.clickStartPosition.y - newPosition.y);

        if (newPositionY < this.height / 2) {
            return;
        }

        if (newPositionY > app.screen.height - (this.height / 2)) {
            return;
        }

        this.y = this.startPositionY - (this.clickStartPosition.y - newPosition.y);
    }


    Events.on(engine, "afterTick", (e) => {
        ballSprite.x = ball.position.x;
        ballSprite.y = ball.position.y;

        Body.setPosition(collider, {x: handle.x, y: handle.y});

    });

    Events.on(engine, 'collisionStart', function(event) {
        let pairs = event.pairs;

        // change object colours to show those starting a collision
        for (let i = 0; i < pairs.length; i++) {
            let pair = pairs[i];

            let kicker = getCollisionObject('kicker', pair);
            let ball = getCollisionObject('ball', pair);

            if(kicker && ball) {
                let direction = Vector.normalise({
                    x: kicker.position.x - ball.position.x,
                    y: kicker.position.y - ball.position.y
                });

                let velocity = 20;
                
                Body.setVelocity(
                    ball,
                    { x: direction.x * velocity, y: direction.y * velocity }
                );
            }
        }
    });

    let getCollisionObject = function(label, pair) {
        if(pair.bodyA.label === label) {
            return pair.bodyA;
        }

        if(pair.bodyB.label === label) {
            return pair.bodyB;
        }

        return null;
    }

</script>

</body>
</html>